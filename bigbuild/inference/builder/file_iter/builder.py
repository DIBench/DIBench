"""
Slide Builder uses a fixed slide window(configured by file number) to generate build file
"""
import glob
import json
from concurrent.futures import ProcessPoolExecutor, as_completed
from pathlib import Path

from bigbuild.sanitize import sanitize
from bigbuild.utils import cprint
from bigbuild.utils.build_system import make_build_system
from bigbuild.utils.llm.provider import make_provider
from bigbuild.utils.repo import fake_git_diff, lang2suffix, show_project_structure

from ..base import Builder, Repo
from ..prompt import file_template, instruction, lazy_prompt, task_information_template

merge_build_files_instruction = """\
Here is a list of edits to a project's build files, which is generated by add \
dependency configuration according to each source file.
Edit the build files to merge all edits in the "Build File Edits" section \
to ensure the project builds and runs successfully. Output a copy of the build file.

You will receive four sections of information to configure dependencies in build files:
1. **Project Structure**: A tree structure representing the project's layout.
2. **Environment Specifications**: Details about the operating system and language SDK where the project will run.
3. **Build File Edits**: A list of edited build file, which you will need to merge.
4. **Build File**: Build files missing dependency configurations, which you will need to update based on above edits.

To suggest changes to a file you MUST return the entire content of the updated file.
You MUST use this *file listing* format:

path/to/filename.js
```
// entire file content ...
// ... goes in between
```

Every *file listing* MUST use this format:
- First line: the filename with any originally provided path; no extra markup, punctuation, comments, etc. **JUST** the filename with path.
- Second line: opening ```
- ... entire content of the file ...
- Final line: closing ```

To suggest changes to a file you MUST return a *file listing* that contains the entire content of the file.
*NEVER* skip, omit or elide content from a *file listing* using "..." or by adding comments like "... rest of code..."!
Create a new file you MUST return a *file listing* which includes an appropriate filename, including any appropriate path.
"""

merge_build_files_task = """\
--- Begin of Project Structure ---
{project_structure}
--- End of Project Structure ---

--- Begin of Environment Specifications ---
{env_specs}
--- End of Environment Specifications ---

--- Begin of Build File Edits---
{build_file_edits}
--- End of Build Files Edits---

--- Begin of Build File ---
{build_section}
--- End of Build File ---"""


def query_llm(
    prompt,
    system_msg,
    max_tokens,
    model_name,
    backend,
    base_url,
):
    engine = make_provider(model_name, backend, base_url)
    response = engine.generate_reply(
        message=prompt,
        n=1,
        max_tokens=max_tokens,
        system_msg=system_msg,
    )[0]
    return prompt, response


def make_patch(
    old_build_file_content: dict[str, str], new_build_file_content: dict[str, str]
) -> str:
    """
    generate a patch file from old_build_file_content to new_build_file_content
    """
    new_build_file_content_aligned = {}
    for file in old_build_file_content:
        if file in new_build_file_content:
            new_build_file_content_aligned[file] = new_build_file_content[file]
        else:
            # if not generated, keep the old content
            new_build_file_content_aligned[file] = old_build_file_content[file]
    return fake_git_diff(
        "playground",
        {
            file: (old_build_file_content[file], new_build_file_content_aligned[file])
            for file in old_build_file_content.keys()
        },
    )


def all_src_files(root: Path, lang_suffix: list[str]) -> list[str]:
    files_to_include = []
    for suffix in lang_suffix:
        for file in glob.glob(f"{root}/**/*{suffix}", recursive=True):
            file = str(Path(file).relative_to(root))
            # exclude setup.py
            if file == "setup.py":
                continue
            files_to_include.append(file)
    return files_to_include


class FileIterBuilder(Builder):
    def __init__(
        self,
        repo: Repo,
        result_dir: Path,
        model_name: str = "gpt-4o-20240806",
        backend: str = "azure",
        resume: bool = True,
        max_seq_len: int = 1000 * 120,
        max_new_tokens: int = 1000 * 8,
        base_url: str | None = None,
    ):
        super().__init__(repo)
        self.repo = repo
        self.model_name = model_name
        self.result_dir = result_dir
        self.resume = resume
        self.trajs = []
        self.max_seq_len = max_seq_len
        self.max_new_tokens = max_new_tokens

        self.build_system = make_build_system(
            self.repo.language.lower(), self.repo.root, self.repo.build_files
        )
        self.build_content = {
            build_file: (Path(repo.root) / build_file).read_text()
            for build_file in repo.build_files
        }
        assert (
            len(self.repo.build_files) > 0
        ), f"No build file found in the repository {self.repo.name}, {self.repo}"
        assert list(self.build_content.keys()) == list(
            self.repo.build_files
        ), f"build files mismatch: {self.build_content.keys()} != {self.repo.build_files} for {self.repo.name}"
        self.backend = backend
        self.base_url = base_url

    def _current_prompt(
        self,
        project_structure: str,
        env_specs: str,
        src_section: str,
    ):
        build_files = ""
        for file in self.repo.build_files:
            content = self.build_content[file]
            build_files += file_template.format(path=file, content=content) + "\n"

        task = task_information_template.format(
            project_structure=project_structure,
            env_specs=env_specs,
            src_section=src_section,
            build_section=build_files,
        )
        # for efficiency
        instruction_ = instruction.replace(
            "1. The project may include multiple build files. Ensure you update all of them with the necessary dependency configurations.",
            "1. The project may include multiple build files. You can only edit some of them with the necessary dependency configurations.",
        )

        lazy_prompt_ = """You are diligent and tireless!
You always COMPLETELY edit the build files you think should be updated!
        """
        prompt = instruction_ + "\n" + task + "\n" + instruction_ + "\n" + lazy_prompt_
        return prompt

    def make_prompt(self):
        engine = make_provider(self.model_name, self.backend, self.base_url)
        root = Path(self.repo.root)
        project_structure = show_project_structure(
            root, exclude_dirs=[".git", ".github"]
        )
        src_files = all_src_files(root, lang2suffix[self.repo.language.lower()])
        env_specs = "\n".join(f"- {k}: {v}" for k, v in self.repo.env_specs.items())
        for file in src_files:
            src_section = file_template.format(
                path=file, content=(root / file).read_text()
            )
            prompt = self._current_prompt(project_structure, env_specs, src_section)
            if engine.count_tokens(prompt) < self.max_seq_len:
                cprint(f"{self.repo.name}: Input {file}", "light_green")
                yield prompt
            else:
                splits = 2
                while True:
                    # splits by line
                    lines = src_section.split("\n")
                    src_splits = [
                        "\n".join(
                            lines[
                                i
                                * len(lines)
                                // splits : (i + 1)
                                * len(lines)
                                // splits
                            ]
                        )
                        for i in range(splits)
                    ]
                    src_splits[0] = src_splits[0] + "\n...\n"
                    src_splits[1] = "\n...\n" + src_splits[1]
                    for i in range(1, splits - 1):
                        src_splits[i] = "\n...\n" + src_splits[i] + "\n...\n"
                    prompts = [
                        self._current_prompt(
                            project_structure,
                            env_specs,
                            file_template.format(path=file, content=content),
                        )
                        for content in src_splits
                    ]
                    if all(
                        engine.count_tokens(prompt) < self.max_seq_len
                        for prompt in prompts
                    ):
                        for prompt in prompts:
                            yield prompt
                        break
                    splits *= 2

    def dump_markdown(self):
        md_file = self.result_dir / "build.md"
        content = f"# {self.repo.name}\n{self.repo}\n"
        for conversation in self.trajs:
            if conversation["role"] == "system":
                content += f"## System\n{conversation['content']}\n"
            elif conversation["role"] == "user":
                content += f"## User\n{conversation['content']}\n"
            elif conversation["role"] == "assistant":
                content += f"## Assistant\n{conversation['content']}\n"
        content += "## Errors\n" + "\n".join(self.errors)
        md_file.write_text(content)

    def patchgen(self):
        if self.resume and (self.result_dir / "patch.diff").exists():
            return
        old_build_content = self.build_content.copy()

        self.errors = []
        system_prompt = f"You are a senior expert in {self.repo.language.lower()}"
        # update build files with each src file
        prompts = list(self.make_prompt())
        new_build_content_list = []
        with ProcessPoolExecutor(max_workers=10) as executor:
            futures = [
                executor.submit(
                    query_llm,
                    prompt,
                    system_msg=system_prompt,
                    max_tokens=self.max_new_tokens,
                    model_name=self.model_name,
                    backend=self.backend,
                    base_url=self.base_url,
                )
                for prompt in prompts
            ]
            for future in as_completed(futures):
                prompt, raw_response = future.result()
                self.trajs.append({"role": "system", "content": system_prompt})
                self.trajs.append({"role": "user", "content": prompt})
                self.trajs.append({"role": "assistant", "content": raw_response})
                new_build_content = sanitize(raw_response, self.repo)
                for file, content in new_build_content.items():
                    if file not in self.build_content:
                        self.errors.append(
                            f"\nWarning[{self.repo.name}]: edited file({file}) not in build files\nWill not be changed this round"
                        )
                        cprint(self.errors[-1], "yellow")
                        continue
                    self.build_content[file] = content
                new_build_content_list.append(new_build_content)

        for build_file in self.repo.build_files:
            origin_content = self.build_content[build_file]
            build_section = file_template.format(
                path=build_file, content=origin_content
            )
            build_file_edits = []
            for new_build_content in new_build_content_list:
                if (
                    build_file not in new_build_content
                    or new_build_content[build_file].strip() == origin_content.strip()
                ):
                    continue
                build_file_edits.append(
                    file_template.format(
                        path=build_file, content=new_build_content[build_file]
                    )
                )
            project_structure = show_project_structure(
                self.repo.root, exclude_dirs=[".git", ".github"]
            )
            task = merge_build_files_task.format(
                project_structure=project_structure,
                env_specs="\n".join(
                    f"- {k}: {v}" for k, v in self.repo.env_specs.items()
                ),
                build_file_edits="\n".join(build_file_edits),
                build_section=build_section,
            )
            prompt = (
                merge_build_files_instruction
                + "\n"
                + task
                + "\n"
                + merge_build_files_instruction
                + "\n"
                + lazy_prompt
            )
            _, response = query_llm(
                prompt,
                system_msg=system_prompt,
                max_tokens=self.max_new_tokens,
                model_name=self.model_name,
                backend=self.backend,
                base_url=self.base_url,
            )
            self.trajs.append({"role": "system", "content": system_prompt})
            self.trajs.append({"role": "user", "content": prompt})
            self.trajs.append({"role": "assistant", "content": response})
            new_build_content = sanitize(response, self.repo)
            if build_file not in new_build_content:
                cprint("Merge build file failed, the file will not be changed", "red")
            else:
                self.build_content[build_file] = new_build_content[build_file]
        (self.result_dir / "trajs.json").write_text(json.dumps(self.trajs))
        self.dump_markdown()
        # patch gen
        patch = make_patch(old_build_content, self.build_content)
        (self.result_dir / "patch.diff").write_text(patch)
        return patch
